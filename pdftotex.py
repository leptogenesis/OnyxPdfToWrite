#the text and ink in the pdf files created by onyx are in annotations. This causes problem with text, as text in successive annotations
#need not be sequential. To avoid this problem at the time being, I am using boxes for each annotation.
#I can position the text in a box using tikz node's. It will also fix the width. an alternative might be to use the eso-pic package. 
#see e.g. https://tex.stackexchange.com/questions/24663/how-to-place-a-floating-text-box-at-a-specified-location-in-page-coordinates?rq=1
#or the packag textpos https://www.liverpool.ac.uk/~maryrees/posterproduction/textpos.pdf

import pdftowrite as pt
import pypdf
import html
import argparse,sys
import os
from lxml import etree

#If this is set to true, the pdf generated by onyx will be reproduced as much as possible
onyx_compatible=True
#if this is not None, it will be used in all widths of strokes
fixedwidth=None
#onyx stores too many points. A subset of the stored points is good enough for a decent pdf file. This makes sure that 1 in every 7 points are used
resample=7

def freetext_to_latex(annot):
   """this function will take an annotation of subtype /Freetex and return a latex text. For the time being, I will just return the "/Contents" of the
   annot. THis does not contain any formatting. I will add the formatting later on. In each annotation, I will also add a blank line after the text"""
   #the xml text which also contains the formatting:
   xmltext=annot["/RC"]
   #this converts html entities to "human readable" form
   xmltext=html.unescape(xmltext)
   #now I need to parse xmltext. First I need to get rid of the encoding part, otherwise lxml complains
   root = etree.fromstring(xmltext[38:])
   tstr=""
   #the spans are in the third layer. Hence
   for tag1 in root:
      for tag2 in tag1:
         if tag2.text.strip().replace("\r","").replace("\n","")=="":
            #there is no text in this tag
            print("there is no string in this tag")
            continue
         #tag2.get("style") give me the style of the text. At this moment, I want to know whether it is a title or not.
         #I will assume that an underline specifies a section title
         style = tag2.get("style")
         #I need to check text-decoration to see  if it is underlined or not
         heading=True
         for css in style[:-1].split(";"):
            key,value=css.split(":")
            if (key == "text-decoration"):
               heading = (heading and value=="underline")
         #if it is underlined, than I will use it as a section
         if heading:
            tstr=tstr+"\n\\section{"+tag2.text.replace("\r"," ").replace("\n","")+"}\n"
         else:
            tstr=tstr+"NNN"+tag2.text.replace("\n","$\\left.\\right.$\\\\")+"\n"
   #for some reason multi spaces seems to create cariage returns which show up as ^M in vim. Here, I am removing them
   #I will first fix the ordering of text. only after that i will try to adjust the size.
   #tstr=tstr.replace("\r"," ")
   return tstr.replace("NNN","\n")

def strike_to_tikz_path(annot):
   """I will use the function points_to_dcommand defined in pdftowrite. Than convert it to a path comment in tikz"""
   points=pt.str_to_points(annot["/AP"]["/N"].get_data().decode())
   color=pt.get_color_from_annot_object(annot)
   color =color[4:-1]
   red,green,blue=color.split(",")
   colorstr="{"+f"rgb,255: red,{red}; green,{green};blue,{blue}"+"}"
   #for some reason, I get a better match if I modify the linewidth by a factor 1.414/2 (which is just 1/sqrt(2))
   #tstr0=f"\\draw[draw={colorstr}, line width={linewidth*1.414/2}pt,dash pattern={dash_pattern(annot)}] "
   if fixedwidth is None:
        linewidth=annot["/BS"]["/W"]*1/3
   else:
        linewidth=fixedwidth
   #there are too many points in ink. I will reduce the number:
   new_points=[]
   iterator=iter(points)
   num=0
   for num in range(len(points)):
      if num % resample == 0:
         new_points.append(points[num])
   if len(points) < resample:
      new_points.append(points[-1])
   points=new_points;
   #belor I have a replacement for L which also replaces the L in SCALE. Hence, I devide the string into two, and combine at the end
   tstr0=f"\\draw[draw={colorstr}, line width={linewidth}pt,dash pattern={dash_pattern(annot)}] "
   tstr=" ".join([val[0].upper()+"("+str(val[1])+"mm,"+str(val[2])+"mm)" for val in points])
   tstr=tstr.replace("M","").replace("L", "-- ")
   tstr=tstr0+tstr+";\n"
   return tstr

def text_in_position(rect,text,scale):
   x1,y1,x2,y2=rect
   width=x2-x1
   tstr="""\\tikz[remember picture,overlay, shift={(current page.north west)}]{ node at[above right] """+f"({x1},{-y1})"+"""[ max width="""+str(width)+"""mm] {"""+text+"};}"
   tstr="""
      \\tikz[scale="""+str(scale)+""", remember picture, overlay, shift={(current page.north west)}]{ \\node[inner sep=0, outer sep=0,draw, anchor=north west, minimum height="""+str((y2-y1)*scale)+"""mm] at"""+f"({x1}mm,{(-y1)}mm)"+"""{
      \\begin{minipage}{"""+str(width*scale)+"""mm}"""+text+"""
      \\end{minipage}};}"""
   return tstr

def polygon_to_latex(annot):
   """this will take an annotation whose subtype is a polygon. The "/Vertices" is a list of numbers specifying the x and y coordinates of the vertices of the
      polynomial"""
   vertices=annot["/Vertices"]
   color=pt.get_color_from_annot_object(annot)
   color =color[4:-1]
   red,green,blue=color.split(",")
   colorstr="{"+f"rgb,255: red,{red}; green,{green};blue,{blue}"+"}"
   iterator = iter(vertices)
   points = ""
   for ver in iterator:
      x,y = [ver,next(iterator)]
      points += f"({x}mm,{y}mm) -- "
   #this is to close the line
   points += "cycle"
   tikz_str = f"\\draw[color={colorstr}, dash pattern={dash_pattern(annot)}] {points};"
   return tikz_str

def circle_to_latex(annot):
   """this function will receive an annotation whose subtype is a circle. in the pdf,
   the "circle" is given as a collection of cubic bezier curves."""
   points = annot["/AP"]["/N"].get_data().decode().splitlines()
   color=pt.get_color_from_annot_object(annot)
   color =color[4:-1]
   red,green,blue=color.split(",")
   colorstr="{"+f"rgb,255: red,{red}; green,{green};blue,{blue}"+"}"
   iterator = iter(points)
   #I need to start with the move to line which ends in m
   moveto="z"
   while moveto[-1] != "m":
      moveto=next(iterator)
   *_,x,y,_ = moveto.split(" ")
   #the coordinates are relative to the rect origin
   X,Y,*_ = annot["/Rect"]
   tikz_str=f"\\draw[color={colorstr}, dash pattern={dash_pattern(annot)}] ({float(x)+X}mm,{float(y)+Y}mm)"
   for bezier in iterator:
      #this skips the last line which is just "S"
      if len(bezier) <= 3:
         continue
      x1,y1,x2,y2,x3,y3,c = bezier.split(" ")
      #(x1,y1) and (x2,y2) are the controls and  (x3,y3) is the final point
      tikz_str += f".. controls ({float(x1)+X}mm,{float(y1)+Y}mm) and ({float(x2)+X}mm,{float(y2)+Y}mm) .. ({float(x3)+X}mm,{float(y3)+Y}mm)"
   #tikz_str should end is a semi colon
   tikz_str += ";"
   return tikz_str

def line_to_latex(annot):
   """apperantly there are more than one kine on line specifications. I need to deal with them separately
   straight line have a single line with no w x1 y2 m x2 y2 l s"""
   color=pt.get_color_from_annot_object(annot)
   color =color[4:-1]
   red,green,blue=color.split(",")
   colorstr="{"+f"rgb,255: red,{red}; green,{green};blue,{blue}"+"}"
   line_str = annot["/AP"]["/N"].get_data().decode()
   tikz_str=""
   lines = line_str.splitlines()
   #there are various cases:
   #straight lines have "l S" in the second line
   #wiiggle lines have no w x y m in the second line and x1 y1 x2 y2 v ,n the remaining lines x1 y1 is the second control point, the first beind the current
   #point https://opensource.adobe.com/dc-acrobat-sdk-docs/pdfstandards/pdfreference1.7old.pdf page 229
   #let me first determine all the drawing commands, and then I can convert it to a tikz drawing command.
   line_commands=[]
   cx1,cy1,cx2,cy2=[0,0,0,0]
   for line in line_str.splitlines():
      #line containing drawing commands end in "l S", "l", "v" or "m" (at least the ones that I have seeni
      #I should skip any other line
      if (line[-1] not in ["l","v","m","S"]) or len(line) < 3:
         continue
      #it is still possible that the line "GS" I need to skip those cases too
      if line[-2:] == "GS":
         continue
      #for the following commands, if the last two strings are " S", I will drop them
      #If I am at this stage, it is likely a drawing command. I should deal with the case separately
      match line[-1]:
         case "m":
            #this is a move to statement. It might, or moght not also contain the width specification. I will ignore it
            *_,x,y,m = line.split(" ")
            line_commands.append([m,float(x),float(y)])
         case "S":
            #this is a line that ends in l S. it is a straight line. this line also contains the m point
            if line[-3:] != "l S":
               print(line)
               raise Exception("this line should end in l S but does not. the line is")
            *_,x1,y1,m,x2,y2,l = line.split(" ")[:-1]
            line_commands.append([m,float(x1),float(y1)])
            line_commands.append([l,float(x2),float(y2)])
         case "v":
            #this is a bezier curve with the first control point as the last point.
            *_, x1,y1,x2,y2,v = line.split(" ")
            line_commands.append([v,float(x1),float(y1),float(x2),float(y2)])
         case "l":
            #this is a line to statement
            x,y,l=line.split(" ")
            line_commands.append([l,float(x),float(y)])
   #I have all the line drawing commands. Now, I need to convert them to tikz drawing command
   #the first one should be an m command. otherwise, there is somethin wrong
   if line_commands[0][0] != "m":
      print(line_commands)
      raise Exception("there is a problem. The first command is not a move to")
   tikz_str=f"\\draw[color={colorstr},dash pattern={dash_pattern(annot)}] "
   #in the tikz commands, the lines will be drawn from x1,y1 to x2,y2 and control points will be cx1,cy1 and cx2,cy2
   for command in line_commands:
      match command[0]:
         case "m":
            m,x1,y1 = command
            #these definitions will be necessary for the v command
            cx1,cy1 = [x1,y1]
            tikz_str += f" ({x1}mm,{y1}mm)"
         case "l":
            l,x2,y2 = command
            cx1,cy1=[x2,y2]
            tikz_str += f" -- ({x2}mm,{y2}mm)"
         case "v":
            v, cx2,cy2,x2,y2 = command
            tikz_str += f" .. controls ({cx1}mm,{cy1}mm) and ({cx2}mm,{cy2}mm) .. ({x2}mm,{y2}mm)"
            cx1,cy1 = [x2,y2]
         case _:
            print(command)
            raise Exception("this is an undefined command. Make sure the add the definition")
   #let me close the tikz_str
   tikz_str += ";\n"
   return tikz_str

def square_to_latex(annot):
   """this is a rectangle annotations. the this line defines the rectangle relative to rect"""
   print("the square data is in",annot["/AP"]["/N"].get_data().decode())
   RX,RY,*_=annot["/Rect"]
   #let me get the color and convert it to tikz format
   color=pt.get_color_from_annot_object(annot)
   color =color[4:-1]
   red,green,blue=color.split(",")
   colorstr="{"+f"rgb,255: red,{red}; green,{green};blue,{blue}"+"}"
   lines = annot["/AP"]["/N"].get_data().decode().splitlines()
   tikz_str=""
   for line in lines:
      if line[-1] != "s":
         continue
      *_,x1,y1,x2,y2,re,s = line.split(" ")
      tikz_str += f"\\draw[draw={colorstr}, dash pattern={dash_pattern(annot)}] ({float(x1)+RX}mm,{float(y1)+RY}mm) rectangle ({float(x2)+RX}mm,{float(y2)+RY}mm);"
   return tikz_str

def dash_pattern(annot):
   """this will extract the dash pattern in the annotations to be used in tikz to draw the lines"""
   string=annot["/AP"]["/N"].get_data().decode()
   dashpattern=""
   #the dash pattearn is specified by the square brackets before a d. I can find it directly by using the split
   if " d" not in string:
      return dashpattern
   string=string.split(" d")
   if len(string)==1:
      return dashpattern
   string = string[0]
   dasharray=string.split("[")[-1].split("]")[0].strip().split(" ")
   toggle="on"
   match len(dasharray):
      case 0:
         dashpatter=""
      case 1:
         dashpattern = f"on SCALE*{dasharray[0]}mm off SCALE*{dasharray[0]}mm"
      case _:
         for leng in dasharray:
            dashpattern += toggle+f" SCALE*{leng}mm "
            if toggle=="on":
               toggle="off"
            else:
               toggle="on"
   return dashpattern.strip()

"""this is the preamble that will be used by default. Onyx does not use any margins.
I should set PW and PH with numerical values before using."""
preamble="""
\\documentclass[11pt]{article}
\\usepackage[utf8]{inputenc}
\\usepackage[margin=0in,paperwidth=PW,paperheight=PH]{geometry}
\\usepackage{tikz}
\\usepackage{color}
"""
if onyx_compatible:
   preamble=preamble+"""
      \\DeclareFontSeriesDefault[rm]{md}{sb}
      \\usepackage{titlesec}
      \\baselineskip=-1em
      \\titlespacing{\\section}{0pt}{0.1em}{-0.2em}
      \\titleformat{\\section}  % which section command to format
         {\\fontsize{10}{11}\\bfseries} % format for whole line
         {\\thesection} % how to show number
         {1em} % space between number and text
         {} % formatting for just the text
         [] % formatting for after the text

      \\titleformat{\\subsection}  % which section command to format
         {\\fontsize{10}{11}\\sffamily} % format for whole line
         {\\S\\thesubsection} % how to show number
         {2em} % space between number and text
         {\\color{blue}} % formatting for just the text
         [] % formatting for after the text
   """
preamble = preamble+"""
\\begin{document}
"""


def pdf_to_latex(infile,outfile,paperwidth=210,paperheight=297):
   reader = pypdf.PdfReader(infile);
   #I will use the size of the first page as the size of the pdf document. I will scale the pt's so that it will fit inside an A4 paper.
   #default size will be A4 paper. A4 size in mm is 210x297
   #paperwidth=210
   #paperheight=297
   if onyx_compatible:
      *_,OW,OH = reader.pages[0]["/MediaBox"]
      scale=min(paperwidth/OW,paperheight/OH)
      paperwidth=round(OW*scale)
      paperheight=round(OH*scale)
   fp = open(outfile,"w")
   fp.write(preamble.replace("PW",f"{paperwidth}mm").replace("PH",f"{paperheight}mm"))
   print(f"there are {len(reader.pages)} pages in the pdf document")
   for page in reader.pages:
      #for free text, I have to first order them in decreasing y coordinate of their rectangle.
      text_str_list=[]
      tikz_str=""
      print("")
      if not "/Annots" in page:
         print(f"Page: {page.page_number} No annotations, skipping",end="\r")
         continue
      iterno=0
      for annot in page["/Annots"]:
         print(f"page: {page.page_number}: {round(iterno/len(page['/Annots'])*100)}%",end="\r")
         iterno+=1
         match annot["/Subtype"]:
            case "/FreeText":
               text_str_list.append([annot["/OnyxRect"],freetext_to_latex(annot)])
            case "/Ink"|"/Stamp":
               tikz_str = tikz_str + strike_to_tikz_path(annot)
            case "/Polygon":
               tikz_str += polygon_to_latex(annot)
            case "/Circle":
               tikz_str += circle_to_latex(annot)
            case "/Line":
               print("This is annotation",page["/Annots"].index(annot))
               tikz_str += line_to_latex(annot)
            case "/Square":
               tikz_str += square_to_latex(annot)
            case _:
               print("I do not know how to deal with the annotation of subtype",annot["/Subtype"])
               print("It is the ",page["/Annots"].index(annot)," annotation in the current page")
      #let me determine the scale factor from the mediabox
      *_,MW,MH = reader.pages[0]["/MediaBox"]
      #this scale should fit strike into an A4 page
      scale=min(paperwidth/MW,paperheight/MH)
      #before writing the text, order them by the y coordinate
      text_str_list.sort(key=lambda item: item[0][1])
      fp.write("\n".join([text_in_position(item[0],item[1],scale) for item in text_str_list]))
      #   fp.write("\\begin{tikzpicture}[yshift=-\\textheight, scale="+str(scale)+",remember picture,overlay]\n")
      fp.write("\\begin{tikzpicture}[scale="+str(scale)+",remember picture,overlay,shift={(current page.south west)}]\n")
      fp.write(tikz_str.replace("SCALE",str(scale)))
      fp.write("\\end{tikzpicture}\n")
      fp.write("\\newpage\n")
   fp.write("\\end{document}")
   fp.close()


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("inputfile")
    parser.add_argument("outputfile",default="output.tex")
    parser.add_argument("-f","--force")
    #if this option is given, all the tikz strokes have the same thickness
    parser.add_argument("-ft","--fixedthickness")
    #onyx stores too many points. if resample number is given, 1 in every resample points are taken.
    parser.add_argument("-rs","--resample",default="7")
    arguments = vars(parser.parse_args())
    force=arguments["force"]
    outfile=arguments["outputfile"]
    infile=arguments["inputfile"]
    if not os.path.exists(infile):
        sys.exit(f"The file {infile} does not exist")
    if os.path.exists(outfile) and not force:
        sys.exit(f"file {outfile} exits. please choose another name or use the -f (--force) option to overwrite the existing file")
    if infile[-3:] != "pdf":
        sys.exit(f"The input file {infile} does not have the correct extension pdf")
    if outfile[-3:] != "tex":
        sys.exit(f"The output file {outfile} does not have the correct extension tex")
    if infile=="output.tex":
        outfile = infile.replace("pdf","tex")
    if "fixedthickness" in arguments:
        fixedwidth=arguments["fixedthickness"]
    if "resample" in arguments:
        resample=arguments["resample"]
        if resample.isdigit():
            resample=int(resample)
        else:
            sys.exit("The an integer should be passed to fixedthickness")
    print(f"converting the file {infile} to latex and saving in {outfile}");
    pdf_to_latex(infile,outfile)
